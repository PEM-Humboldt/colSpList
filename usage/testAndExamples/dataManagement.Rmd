---
title: "Functionality tests and examples for the colSpListAPI: data management"
output: 
  github_document:
    toc: true
    number_section: true
---

In this document, we will test the endpoints of the colSpList API which allow to manage users and some specific administrative tasks.

************************

**Note**:

This document was created from a Rmarkdown document, with the output format "github_document".
In order to use this type of file, please install the packages *knitr* and *rmarkdown* in R.

1. If you want to compile the document as a markdown document for github, while applying all the code contained in the file
    + use ```rmarkdown::render("file.Rmd")```
2. The python script is extracted from the Rmd document using (in R):
    + ```source "../../extra/extractPythonRmd.R"; extractPythonRmd("file.Rmd")``
    
***********************

```{python}
import requests
from requests.auth import HTTPBasicAuth
from flask import jsonify
api_url="http://localhost:5000"
```


# Before starting

In order to apply the code of this document, we will need to have access to user management and administrative right.
Since I cannot share here the code for the admin user, I created a file called "codeAdmin" which contains the code of the admin user. This file has been excluded from the gitHub folder.
In order to be able to show all the possibilities of data management in this document, I will:

* change the admin code for 'temporaryAdminCode'
* create a user with edition rights

Note that the following code is not part of the functionality tests, but actually uses the same endpoints.


```{python}
f=open("codeAdmin","r")
codeAdmin=f.readline().replace('\n','')
f.close()
endpoint="/user"
authAdmin=HTTPBasicAuth('admin',codeAdmin)
requests.put(api_url+endpoint,auth=authAdmin,json={'newPassword':'temporaryAdminCode'})
authAdmin=HTTPBasicAuth('admin','temporaryAdminCode')
resToken=requests.get(api_url+endpoint,auth=authAdmin,json={'create_token':'True'})
content=resToken.json()
authTokenAdmin =HTTPBasicAuth(content.get('token'),'token')
# creation user with edit right
res = requests.post(api_url+endpoint,json={'username':'editUser','password':'tempCode2'})
res.json()
# grant edit to editUser
endpoint = "/admin/users"
res=requests.put(api_url+endpoint,json={'username':'editUser','grant_edit':'True'},auth=authTokenAdmin)
res.json()
# Getting the tokens for these new users:
endpoint="/user"
authEditUser=HTTPBasicAuth('editUser','tempCode2')
res= requests.get(api_url+endpoint,json={'create_token':'True'},auth=authEditUser)
content=res.json()
authTokenEditUser=HTTPBasicAuth(content.get('token'),'token')
```

# Endpoint /manageTaxo
The endpoint '/manageTaxo' allows to add (POST), suppress (DELETE) or modify (PUT) taxonomic information in the database.

```{python}
endpoint="/manageTaxo"
```


## POST

In most of the case, sending only the canonical name of the taxa will be sufficient to insert a new taxon:

```{python}
newTax1={'canonicalname':'Abies grandis'}
res=requests.post(api_url+endpoint,json=newTax1,auth=authTokenEditUser)
res.json()
```

The API send back all the informations from the database or the GBIF API, and the "insertedTax" part of the results shows which taxa were inserted.

It might be important to look at the "matchedname", to be sure that the inserted taxon is the one we wanted to insert.

If the species we want to insert already exists in the database, here are what the results look like:


```{python}
newTax2={'canonicalname':'Vultur gryphus'}
res=requests.post(api_url+endpoint,json=newTax2,auth=authTokenEditUser)
res.json()
```

You may also insert taxa from their key in the gbif database, or their scientificName (with author):

```{python}
newTax3={'gbifkey':7963890}
res=requests.post(api_url+endpoint,json=newTax3,auth=authTokenEditUser)
res.json()
newTax4={'scientificname':'Juniperus thurifera'}
res=requests.post(api_url+endpoint,json=newTax4,auth=authTokenEditUser)
res.json()
```

Sometimes, the taxa found through the gbif API may be problematic:

```{python}
newTax5={'canonicalname':'Vultur fossilis'}
res=requests.post(api_url+endpoint,json=newTax5,auth=authTokenEditUser)
res.json()
```

As you can see the GBIF API does not find the species, which is a doubtfuk synonym for the condor 'Vultur gryphus', hence, it matches it with the genus.
To avoid these problem, you might want to set the 'min_conf_gbif' parameter to a higher value:

```{python}
newTax5={'canonicalname':'Vultur fossilis','min_gbif_conf':98}
res=requests.post(api_url+endpoint,json=newTax5,auth=authTokenEditUser)
res.json()
```

The problem here is that it actually inserted the taxon without extracting the information from gbif.
Here is what looks 'Vultur fossilis' in the database:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Vultur fossilis'})
res.json()
```

It inserted the taxon with the status 'DOUBTFUL', but it inserted it anyway!
A good practise would be to revise regularly the taxonomic data (<https://colsplist.herokuapp.com/listTax?format=CSV>) and particularly all the 'DOUBTFUL' taxa.


Another way to avoid matching in gbif is to use the parameter 'no_gbif' in the function.

```{python}
newTax6={'canonicalname':'Juniperus communis','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax6,auth=authTokenEditUser)
res.json()
```

Until now we used the functions with very few parameters, but if you want to insert a taxon which has no close parent in the database and is not found in gbif, you might need to use more parameters.

Let's imagine a virtual taxon that we invent for the current demonstration:

The species 'Invented species' is from the genus 'Invented', which is part of the family 'Fabaceae', already in the database:

If we simply send the 'Invented species' to the API, here is what happens:

```{python}
newTax8 = {'canonicalname':'Invented species'}
res=requests.post(api_url+endpoint,json=newTax8,auth=authTokenEditUser)
res.json()
```

As you can see, the parent taxon is not found which is what we would have expected...
Therefore, we need to insert the parent taxon first, and then to insert the taxon, which will automatically be assigned to the right genus.
In order to make things right, we should give a maximum amount of informations to the API:

```{python}
newTax7={'canonicalname':'Invented','scientificname':'Invented (marius, 2022)','authorship':'(marius, 2022)','parentcanonicalname':'Fabaceae','syno':False,'rank':'GENUS','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax7,auth=authTokenEditUser)
res.json()
parentId=res.json().get('cd_tax')
```

Now we insert the taxon with:

```{python}
newTax8={'canonicalname':'Invented species','scientificname':'Invented species (marius, 2022)','authorship':'(marius, 2022)','parentcanonicalname':'Invented','syno':False,'rank':'SPECIES','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax8,auth=authTokenEditUser)
res.json()
taxId=res.json().get('cd_tax')
```

Now we can see what are these new taxa like in the database:

```{python}
res=requests.get(api_url+'/tax',json={'cd_tax':parentId})
res.json()
res=requests.get(api_url+'/tax',json={'cd_tax':taxId})
res.json()
```

## PUT
The PUT method allows to modify a taxon which is already in the database

### With gbifkey
The easiest way to use this method is to provide a gbifkey, so the taxon designated by the cd_tax is modified to become exactly like the taxon referred by the gbifkey.

For example, we inserted the taxon *Juniperus communis* without using GBIF, with the no_gbif option. When we look at the taxon in the database, here is what we obtain:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Juniperus communis'})
res.json()
modified1={'cd_tax':res.json().get('cd_tax')}
```

But this taxon is actually present in GBIF with more accurate information. In order to modify the taxon, you just have to use the following code:

```{python}
modified1['gbifkey']=2684709
res=requests.put(api_url+endpoint, json=modified1, auth=authTokenEditUser)
```

Now, the taxon has this information:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Juniperus communis'})
res.json()
```

As you can see, the cd_tax is the same as before (which avoids problems in case the taxon has a status, but the information is now more complete)

### With provided parameters

Let's go back to the taxon that we invented "Invented species":


```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'})
res.json()
modified2Id = res.json().get('cd_tax')
```

Modifying its authorship and scientificname may be done by:

```{python}
modified2={'cd_tax':modified2Id,'authorship':'(marius 2005)','scientificname':'Invented species (marius 2005)'}
res=requests.put(api_url+endpoint, json=modified2, auth=authTokenEditUser)
res.json
```

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'})
res.json()
modified2Id = res.json().get('cd_tax')
```

As you can see the year associated with the authorship has been changed, you may as well use the parameters:

* canonicalname: changes the canonicalName of the taxon
* syno: change the synonym status of the taxon
* rank : change the rank of the taxon (the safest way to write the rank is "SPECIES", "FAMILY","VARIETY" etc.)
* parentgbifkey,parentcanonicalname, parentscientificname: change the parent taxon, if the taxon is not present in the database, search for it in the gbif API, and inserts it. Note that if you do not want to use GBIF for the parent taxa, you will have to modify or insert the parents (with POST) one by one
* synogbifkey, synocanonicalname, and synoscientificname: search for the accepted name in the GBIF API if it does not exist in the database, inserts it and use it to consider cd_tax as a synonym to the acceptedname. Note that if you do not want to pass by the GBIF API, you will have to enter the accepted taxon with the POST method and the 'no_gbif' option

## DELETE

The DELETE method allows the user to delete a taxon and all its statuses in the database

If we want to delete, say the taxon 'Abies grandis' which we inserted before it is done by first, finding its code in the database, and then the DELETE method.

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname': 'Abies grandis'})
res.json()
del1={'cd_tax':res.json().get('cd_tax')}
res=requests.delete(api_url+endpoint,json=del1,auth=authTokenEditUser)
res.json()
```

As you can see the API returns the synonyms and children cd_tax, so that you can avoid problematic taxa kept in the database.

# Finally : getting back to the previous state

Here, I will delete the users that were created for this document and give back the previous password to the 'admin' user:


```{python}
endpoint="/admin/users"
# Deleting the users created for this document
userToDel={'username':'editUser'}
res=requests.delete(api_url+endpoint,json=userToDel,auth=authAdmin)
res.json()
endpoint="/user"
res=requests.put(api_url+endpoint,json={'newPassword':codeAdmin},auth=authTokenAdmin)
res.json()

```