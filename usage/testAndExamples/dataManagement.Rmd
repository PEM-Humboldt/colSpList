---
title: "Functionality tests and examples for the colSpListAPI: data management"
output: 
  github_document:
    toc: true
    number_section: false
---

In this document, we will test the endpoints of the colSpList API which allow to manage users and some specific administrative tasks.

************************

**Note**:

This document was created from a Rmarkdown document, with the output format "github_document".
In order to use this type of file, please install the packages *knitr* and *rmarkdown* in R.

1. If you want to compile the document as a markdown document for github, while applying all the code contained in the file
    + use ```rmarkdown::render("file.Rmd")```
2. The python script is extracted from the Rmd document using (in R):
    + ```source("../../extra/extractPythonRmd.R"); extractPythonRmd("file.Rmd")``
    
***********************

```{python}
import requests
from requests.auth import HTTPBasicAuth
from flask import jsonify
from pprint import pprint as pp
api_url="https://colsplist.herokuapp.com"
```


# Before starting

In order to apply the code of this document, we will need to have access to user management and administrative right.
Since I cannot share here the code for the admin user, I created a file called "codeAdmin" which contains the code of the admin user. This file has been excluded from the gitHub folder.
In order to be able to show all the possibilities of data management in this document, I will:

* change the admin code for 'temporaryAdminCode'
* create a user with edition rights

Note that the following code is not part of the functionality tests concerning data management.


```{python}
f=open("codeAdmin","r")
codeAdmin=f.readline().replace('\n','')
f.close()
authAdmin=HTTPBasicAuth('admin',codeAdmin)
requests.put(api_url+'/user',auth=authAdmin,json={'newPassword':'temporaryAdminCode'})
authAdmin=HTTPBasicAuth('admin','temporaryAdminCode')
resToken=requests.get(api_url+'/user',auth=authAdmin,json={'create_token':'True'})
content=resToken.json()
authTokenAdmin =HTTPBasicAuth(content.get('token'),'token')
# creation user with edit right
res = requests.post(api_url+'/user',json={'username':'editUser','password':'tempCode2'})
pp(res.json())
# grant edit to editUser
res=requests.put(api_url+'/admin/users',json={'username':'editUser','grant_edit':'True'},auth=authTokenAdmin)
pp(res.json())
# Getting the tokens for these new users:
authEditUser=HTTPBasicAuth('editUser','tempCode2')
res= requests.get(api_url+'/user',json={'create_token':'True'},auth=authEditUser)
content=res.json()
authTokenEditUser=HTTPBasicAuth(content.get('token'),'token')
```

# Endpoint /manageTaxo
The endpoint '/manageTaxo' allows to add (POST), suppress (DELETE) or modify (PUT) taxonomic information in the database.

```{python}
endpoint="/manageTaxo"
```


## POST

In most of the case, sending only the canonical name of the taxa will be sufficient to insert a new taxon:

```{python}
newTax1={'canonicalname':'Abies grandis'}
res=requests.post(api_url+endpoint,json=newTax1,auth=authTokenEditUser)
pp(res.json())
```

The API send back all the informations from the database or the GBIF API, and the "insertedTax" part of the results shows which taxa were inserted.

It might be important to look at the "matchedname", to be sure that the inserted taxon is the one we wanted to insert.

If the species we want to insert already exists in the database, here are what the results look like:


```{python}
newTax2={'canonicalname':'Vultur gryphus'}
res=requests.post(api_url+endpoint,json=newTax2,auth=authTokenEditUser)
pp(res.json())
```

You may also insert taxa from their key in the gbif database, or their scientificName (with author):

```{python}
newTax3={'gbifkey':7963890}
res=requests.post(api_url+endpoint,json=newTax3,auth=authTokenEditUser)
pp(res.json())
newTax4={'scientificname':'Juniperus thurifera'}
res=requests.post(api_url+endpoint,json=newTax4,auth=authTokenEditUser)
pp(res.json())
```

Sometimes, the taxa found through the gbif API may be problematic:

```{python}
newTax5={'canonicalname':'Vultur fossilis'}
res=requests.post(api_url+endpoint,json=newTax5,auth=authTokenEditUser)
pp(res.json())
```

As you can see the GBIF API does not find the species, which is a doubtful synonym for the condor 'Vultur gryphus', hence, it matches it with the genus.
To avoid these problem, you might want to set the 'min_conf_gbif' parameter to a higher value:

```{python}
newTax5={'canonicalname':'Vultur fossilis','min_gbif_conf':98}
res=requests.post(api_url+endpoint,json=newTax5,auth=authTokenEditUser)
pp(res.json())
```

The problem here is that it actually inserted the taxon without extracting the information from gbif.
Here is what looks 'Vultur fossilis' in the database:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Vultur fossilis'})
pp(res.json())
```

It inserted the taxon with the status 'DOUBTFUL', but it inserted it anyway!
A good practise would be to revise regularly the taxonomic data (<https://colsplist.herokuapp.com/listTax?format=CSV>) and particularly all the 'DOUBTFUL' taxa.


Another way to avoid matching in gbif is to use the parameter 'no_gbif' in the function.

```{python}
newTax6={'canonicalname':'Juniperus communis','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax6,auth=authTokenEditUser)
pp(res.json())
```

Until now we used the functions with very few parameters, but if you want to insert a taxon which has no close parent in the database and is not found in gbif, you might need to use more parameters.

Let's imagine a virtual taxon that we invent for the current demonstration:

The species 'Invented species' is from the genus 'Invented', which is part of the family 'Fabaceae', already in the database:

If we simply send the 'Invented species' to the API, here is what happens:

```{python}
newTax8 = {'canonicalname':'Invented species'}
res=requests.post(api_url+endpoint,json=newTax8,auth=authTokenEditUser)
pp(res.json())
```

As you can see, the parent taxon is not found which is what we would have expected...
Therefore, we need to insert the parent taxon first, and then to insert the taxon, which will automatically be assigned to the right genus.
In order to make things right, we should give a maximum amount of informations to the API:

```{python}
newTax7={'canonicalname':'Invented','scientificname':'Invented (marius, 2022)','authorship':'(marius, 2022)','parentcanonicalname':'Fabaceae','syno':False,'rank':'GENUS','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax7,auth=authTokenEditUser)
pp(res.json())
parentId=res.json().get('cd_tax')
```

Now we insert the taxon with:

```{python}
newTax8={'canonicalname':'Invented species','scientificname':'Invented species (marius, 2022)','authorship':'(marius, 2022)','parentcanonicalname':'Invented','syno':False,'rank':'SPECIES','no_gbif':True}
res=requests.post(api_url+endpoint,json=newTax8,auth=authTokenEditUser)
pp(res.json())
taxId=res.json().get('cd_tax')
```

Now we can see what are these new taxa like in the database:

```{python}
res=requests.get(api_url+'/tax',json={'cd_tax':parentId})
pp(res.json())
res=requests.get(api_url+'/tax',json={'cd_tax':taxId})
pp(res.json())
```

## PUT
The PUT method allows to modify a taxon which is already in the database

### With gbifkey
The easiest way to use this method is to provide a gbifkey, so the taxon designated by the cd_tax is modified to become exactly like the taxon referred by the gbifkey.

For example, we inserted the taxon *Juniperus communis* without using GBIF, with the no_gbif option. When we look at the taxon in the database, here is what we obtain:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Juniperus communis'})
pp(res.json())
modified1={'cd_tax':res.json().get('cd_tax')}
```

But this taxon is actually present in GBIF with more accurate information. In order to modify the taxon, you just have to use the following code:

```{python}
modified1['gbifkey']=2684709
res=requests.put(api_url+endpoint, json=modified1, auth=authTokenEditUser)
```

Now, the taxon has this information:

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Juniperus communis'})
pp(res.json())
```

As you can see, the cd_tax is the same as before (which avoids problems in case the taxon has a status, but the information is now more complete)

### With provided parameters

Let's go back to the taxon that we invented "Invented species":


```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'})
pp(res.json())
modified2Id = res.json().get('cd_tax')
```

Modifying its authorship and scientificname may be done by:

```{python}
modified2={'cd_tax':modified2Id,'authorship':'(marius 2005)','scientificname':'Invented species (marius 2005)'}
res=requests.put(api_url+endpoint, json=modified2, auth=authTokenEditUser)
pp(res.json())
```

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'})
pp(res.json())
modified2Id = res.json().get('cd_tax')
```

As you can see the year associated with the authorship has been changed, you may as well use the parameters:

* canonicalname: changes the canonicalName of the taxon
* syno: change the synonym status of the taxon
* rank : change the rank of the taxon (the safest way to write the rank is "SPECIES", "FAMILY","VARIETY" etc.)
* parentgbifkey,parentcanonicalname, parentscientificname: change the parent taxon, if the taxon is not present in the database, search for it in the gbif API, and inserts it. Note that if you do not want to use GBIF for the parent taxa, you will have to modify or insert the parents (with POST) one by one
* synogbifkey, synocanonicalname, and synoscientificname: search for the accepted name in the GBIF API if it does not exist in the database, inserts it and use it to consider cd_tax as a synonym to the acceptedname. Note that if you do not want to pass by the GBIF API, you will have to enter the accepted taxon with the POST method and the 'no_gbif' option

## DELETE

The DELETE method allows the user to delete a taxon and all its statuses in the database

If we want to delete, say the taxon 'Abies grandis' which we inserted before it is done by first, finding its code in the database, and then the DELETE method.

```{python}
res=requests.get(api_url+'/tax',json={'canonicalname': 'Abies grandis'})
pp(res.json())
del1={'cd_tax':res.json().get('cd_tax')}
res=requests.delete(api_url+endpoint,json=del1,auth=authTokenEditUser)
pp(res.json())
```

As you can see the API returns the synonyms and children cd_tax, so that you can avoid problematic taxa kept in the database.


Note that the statuses of the deleted species will also be deleted (as a "ON DELETE CASCADE" process in the postgres database, so the information will be lost... proceed with caution!)


# endpoint /manageTaxo/list : for multiple taxa

This endpoints work the same than the previous one, except that the json dictionaries presented before as argument have to be encapsuled in a "list" element of a JSON dictionary, which may contain many taxa.

In order to run the examples presented before again, I will first supress the taxa using the "/cleanDb" endpoint. Since the inserted taxa have no status, the 'tax_no_status' argument should be sufficient to get rid of all the newly inserted taxa (More information on <https://github.com/marbotte/colSpList/blob/main/usage/testAndExamples/userManagementAdministration.md#cleandb>)

```{python}
res=requests.delete(api_url+'/cleanDb',json={'tax_no_status':True},auth=authTokenEditUser)
pp(res.json())
```
```{python}
endpoint='/manageTaxo/list'
```


## POST

You may send all the previous taxon in one only batch using the following dictionary:

```{python}
multiNewTax={'list':[newTax1,newTax2,newTax3,newTax4,newTax5,newTax6,newTax7,newTax8]}
pp(multiNewTax)
```

```{python}
res=requests.post(api_url+endpoint,json=multiNewTax,auth=authTokenEditUser)
pp(res.json())
```

## DELETE

Let's delete the 'Abies grandis' and 'Juniperus thurifera' taxa.

First we search their cd_tax:

```{python}
res=requests.post(api_url+'/tax/list',json={'list':[{'canonicalname':'Abies grandis'},{'canonicalname':'Juniperus thurifera'}]})
pp(res.json())
cdTaxToDel=[{'cd_tax':r['cd_tax']} for r in res.json()]
pp(cdTaxToDel)
```


Then we send them to the DELETE method of the endpoint

```{python}
res=requests.delete(api_url+endpoint, json={'list':cdTaxToDel},auth=authTokenEditUser)
pp(res.json())
```

## PUT

Again it is possible to send all the modification at once.

So here is the command to modify both the species we modified as well in the simple version:


```{python}
res=requests.post(api_url+'/tax/list',json={'list':[{'canonicalname':'Juniperus communis'},{'canonicalname':'Invented species'}]})
pp(res.json())
ToModify=[{'cd_tax':r['cd_tax']} for r in res.json()]
ToModify[0]['gbifkey']=2684709
ToModify[1].update({'authorship':'(marius 2005)','scientificname':'Invented species (marius 2005)'})
pp(ToModify)
```

```{python}
res=requests.put(api_url+endpoint,json={'list':ToModify},auth=authTokenEditUser)
res.text
res=requests.post(api_url+'/tax/list',json={'list':[{'canonicalname':'Juniperus communis'},{'canonicalname':'Invented species'}]})
pp(res.json())
```


# Managing the statuses

There are 6 endpoints for managing species statuses: */manageEndem* and */manageEndem/list* (endemic species), */manageExot* and */manageExot/list* (alien/invasive species) and */manageThreat* and */manageThreat/list*. 

Important notes:

* you can use directly these endpoint with the POST method to insert new taxa together with their statuses. In these cases the functions used are for taxon insertions are exactly the same than in the */manageTaxo* and */manageTaxo/list*. Therefore you can use exactly the same arguments and get exactly the same results as what I described previously in this document.
* the status are always given to the **accepted taxon**, even though the taxon provided is the synonym



## Endpoint /ManageEndem

```{python}
endpoint='/manageEndem'
```


### POST: adding endemic species and/or the associated bibliographic references

The formally required arguments to post an endemic status are:

* **endemstatus** (see table \ref{tab:endemstatus}): the description of the endemism status for the taxon
* **ref_citation**: A list of bibliographic references associated with the endemic status.

However, of course you will need at least one of 'canonicalname', 'scientificname' or 'gbifkey', for the API to know which taxon the endemic status refer to...

```{r,echo=FALSE,message=FALSE,error=FALSE}
require(RPostgres)&require(knitr)
try({
  connected=F
  db <- dbConnect(Postgres(),dbname="sp_list")
  if(length(ls(pattern="^db$"))==1){
    connected=T
  }
},silent=T)
if(!connected){
  kable(data.frame(message="There is no database called sp_list: we cannot show the table"),caption="Table for endemic status not found",label="endemstatus")
}else{
  kable(dbReadTable(db,"nivel_endem"),caption="Table for endemic status description",label="endemstatus")
}
```

#### Adding a status to an existing species


Let's add an endemic status to the virtual species we invented ('Invented species')

```{python}
status1={'canonicalname':'Invented species',
  'endemstatus':'Información insuficiente',
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A second reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'This is a first comment | Feeding habits: Does not eat at all!'}
res=requests.post(api_url+endpoint,json=status1,auth= authTokenEditUser)
pp(res.json())
```

Now, if we use the /testEndem endpoint for this species, we will obtain:

```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'})
pp(res.json())
```

#### Adding a status and a species in one command


Let's invent a new species again : "Newspecies nonexistens", it will have an "Endemic":

```{python}
status2={'canonicalname':'Newspecies nonexistens',
  'scientificname':'Newspecies nonexistens (marius 2022)',
  'authorship':'(marius 2022)',
  'parentcanonicalname':'Invented',
  'endemstatus':'Endemic',
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A third reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'random comment | repartition: nula'}
res=requests.post(api_url+endpoint,json=status2,auth= authTokenEditUser)
pp(res.json())

```

#### Error: endemic status not recognised

El argumento 'endemstatus' accepts any value shown in the previous table.
However, a simple orthographic results in an error.

For example:
Let's add the status 'Almost end**a**mic' to *Juniperus communis*:

```{python}
requests.get(api_url+'/testEndem',json={'canonicalname':'Juniperus communis'}).json()
status3={'canonicalname':'Juniperus communis',
  'endemstatus':'Almost endamic',
  'ref_citation':['Bottin et al, 2022. False paper to show an example'],
  'link':['https://colsplist.herokuapp.com'],
  'comments':'random comment | repartition: nula'}
res=requests.post(api_url+endpoint,json=status3,auth= authTokenEditUser)
pp(res.json())
```

If the status provided is not recognized as one of the way to designate the status (in english, in spanish or as a code from 0 to 4 in character), the function send back this error.

#### What if the status already exists in the database

When the status already exists in the database, the behavior of the API depends on 2 parameters:

* priority: if 'high', the previous status is replaced, references are added (old references are kept anyway). I 'low' the previous status is kept, references are added.
* replace_comment: if True, the comments provided replace the old comments, otherwise comments are added to the existing ones (with a '|' separator)

Note that:

* the most logical cases are Priority:low + replace_comment:False or priority:high, replace_comment:True, but you might as well use priority and replace_comment independently to each other.
* There is no way to avoid that comments are either added or replacing old ones. So if you want to avoid comments to be inserted when the status already exists you will have to first test whether the statuses exist before sending data to the post method (with the '/testEndem(/list)' endpoint: see <https://github.com/marbotte/colSpList/blob/main/usage/testAndExamples/basic_getEndpoints_functionality.md#testendem>).
* If priority is None (or is not provided by the user) and the status of the species is the same than in the database, the references and comment are added (with the method replace_comment or not) and no error is sent
* If priority is None (or is not provided by the user) and the status of the species different, an error is sent and no modification is made in the database.



##### example 1: priority:low, replace_comment:False

Let's say that we send again a status for the species *Newspecies nonexistens*, this time "Almost endemic", with the new reference: "Bottin, 2025. New fake reference with a weird date", and the comments. "endemism evaluation methodology: None, this is only a fake species!"


As a reminder, here is the current status of the species:

```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

Now we modify it with:

```{python}
status4={'canonicalname':'Newspecies nonexistens',
  'endemstatus':'Almost endemic',
  'comments':'endemism evaluation methodology: None, this is only a fake species!',
  'ref_citation':['Bottin, 2025. New fake reference with a weird date'],
  'priority':'low',
  'replace_comment':False
}
pp(requests.post(api_url+'/manageEndem',json=status4,auth=authTokenEditUser).json())
```


The new endemism status is:

```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```
As you can see:

* new reference was added
* new comment was added
* endemism stayed the same


##### example 2: priority: high, replace_comment:True

```{python}
status5={'canonicalname':'Newspecies nonexistens',
  'endemstatus':'Almost endemic',
  'comments':'endemism evaluation methodology 2: None, this is still only a fake species!',
  'ref_citation':['Bottin, 2026. New fake reference with a weirder date'],
  'priority':'high',
  'replace_comment':True
}
pp(requests.post(api_url+'/manageEndem',json=status5,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

As you can see:

* new reference was added
* comments were replaced
* endemism changed into 'Almost endemic'

### PUT: modify a status

The PUT method here is exactly the same than the POST method with 'priority':'high'. The only difference is that it will send an error if the status does not exist. The rationale is that they are used in different context.
The POST method is used when a new dataset is available, and people want to update the information on the API, while the PUT method is used when some errors or inconsistencies are found in the API data...

Imagine that we found new data for 'Invented species': it is now accepted in the literature as 'Species of interest'



```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'})
pp(res.json())
cd_tax=res.json().get('cd_tax_acc')
```


```{python}
status6={'cd_tax':cd_tax,
  'endemstatus':'Species of interest',
  'ref_citation':['Bottin, 2051. New fake reference with the weirdest date'],
}
pp(requests.put(api_url+'/manageEndem',json=status6,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'})
pp(res.json())
```

### DELETE: suppress a reference associated with a status, or the status itself

The DELETE method, by default, concerns the references associated to a status. If what you want to delete is the status, you have to use the 'delete_status' argument.

#### Deleting an association between a taxon status and a reference

The first thing to do is to search for the cd_ref and cd_tax corresponding respectively to the reference and the taxon.

In order to suppress the association between the reference 'Bottin et al, 2022. False paper to show an example' and the taxon 'Invented species', here is the way to search for the codes automatically:

```{python}
listRef=requests.get(api_url+'/listReferences').json()
cd_ref = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
pp(cd_ref)
cd_tax=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'}).json()['cd_tax']
pp(cd_tax)
```
Let's take a look at the endemic status of *Invented species*.

```{python}
pp(requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'}).json())
```


Here to suppress the association:

```{python}
res=requests.delete(api_url+'/manageEndem', json={'cd_tax':cd_tax,'cd_ref':cd_ref},auth=authTokenEditUser)
pp(res.json())
```


```{python}
pp(requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'}).json())
```

#### Deleting an association between a taxon status and a reference

If the delete method is called only with a cd_tax here is what happens:


```{python}
pp(requests.delete(api_url + '/manageEndem',json={'cd_tax':cd_tax},auth=authTokenEditUser).json())
```

As said, to delete the endemic status of 'Invented species', what should be done is:


```{python}
pp(requests.delete(api_url + '/manageEndem',json={'cd_tax':cd_tax,'delete_status':True},auth=authTokenEditUser).json())
```


```{python}
pp(requests.get(api_url+'/testEndem',json={'canonicalname':'Invented species'}).json())
```


### Cleaning

**Species to suppress**: 

'Newspecies nonexistens'

**References to suppress**:

'Bottin et al, 2022. False paper to show an example','A second reference just for fun!','A third reference just for fun!','Bottin, 2025. New fake reference with a weird date','Bottin, 2026. New fake reference with a weirder date','Bottin, 2051. New fake reference with the weirdest date'


```{python}
cd_tax_ToDel=requests.get(api_url + '/tax',json={'canonicalname':'Newspecies nonexistens'}).json().get('cd_tax')
requests.delete(api_url+'/manageTaxo',json={'cd_tax':cd_tax_ToDel},auth=authTokenEditUser)
cd_tax_StatusToDel=requests.get(api_url + '/testEndem',json={'canonicalname':'Invented species'}).json().get('cd_tax')
res=requests.delete(api_url+'/manageEndem',json={'cd_tax':cd_tax_StatusToDel, 'delete_status':True}, auth=authTokenEditUser)
res=requests.delete(api_url+'/cleanDb',json={'ref_no_status':True}, auth=authTokenEditUser)
```



## Endpoint /manageEndem/list

The endpoint /manageEndem/list works exactly like the endpoint /manageEndem, except that all the insertions, modifications or deletions may be done at once with a list.

### POST

See explanation in section POST of the /manageEndem endpoint.



We will show here how to post multiple statuses in a single call to the API.

Of course, many of these statuses concern the species "Newspecies nonexistens", which is not the intended objective of the multiple version in the endpoint /manageEndem/list, but the objective here is to show a proof of concept...

```{python}
statuses=[status1,status2,status3,status4,status5]
pp(statuses)
res=requests.post(api_url + '/manageEndem/list',json={'list':statuses},auth=authTokenEditUser)
pp(res.json())
```




### PUT

We will show here how to modify multiple statuses in a single call to the API.

```{python}
newSpecies=requests.post(api_url+'/testEndem/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json()
pp(newSpecies)
newSpecies_cd_tax=[n['cd_tax_acc'] for n in newSpecies]
modifications={'list':
  [
    {
      'cd_tax': newSpecies_cd_tax[0],
      'endemstatus':'Casi endémicas por área',
      'ref_citation':['Fake report to put Invented species as Almost endemic by area'],
      'link':['https://www.afalsesiteasanexample.com'],
      'comments': 'a comment as replacement',
      'replace_comment':True
    },
    {
      'cd_tax': newSpecies_cd_tax[1],
      'endemstatus':'Endemic',
      'ref_citation':['Another fake report'],
      'comments': 'a comment to add',
    }
  ]
}
pp(modifications)
modifs=requests.put(api_url + '/manageEndem/list',json=modifications,auth=authTokenEditUser).json()
pp(modifs)
pp(requests.post(api_url+'/testEndem/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```




### DELETE

We will show here how to delete multiple references/statuses in a single call to the API.

We will suppress the references 'Bottin et al, 2022. False paper to show an example' and 'Fake report to put Invented species as Almost endemic by area' as justifications for *Invented species*, and delete the endemic status for *Newspecies nonExistens*

```{python}
pp(requests.post(api_url+'/testEndem/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
listRef=requests.get(api_url+'/listReferences').json()
cd_ref1 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
cd_ref2 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Fake report to put Invented species as Almost endemic by area'][0]
deletions=[
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref1},
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref2},
  {'cd_tax':newSpecies_cd_tax[1],
  'delete_status':True}
]
pp(deletions)
pp(requests.delete(api_url + '/manageEndem/list',json={'list':deletions},auth=authTokenEditUser).json())
pp(requests.post(api_url+'/testEndem/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```

### Cleaning

```{python}
pp(requests.delete(api_url + '/cleanDb',json={'status_no_ref':True,'ref_no_status':True},auth=authTokenEditUser).json())
pp(requests.delete(api_url + '/manageTaxo', json={'cd_tax':newSpecies_cd_tax[1]}, auth=authTokenEditUser).json())
```

## Endpoint /ManageThreat

```{python}
endpoint='/manageThreat'
```


### POST: adding threatened species and/or the associated bibliographic references

The formally required arguments to post a threatened status are:

* **threatstatus** (see table \ref{tab:threatstatus}): IUCN code threat status for the taxon
* **ref_citation**: A list of bibliographic references associated with the threat status.

However, of course you will need at least one of 'canonicalname', 'scientificname' or 'gbifkey', for the API to know which taxon the threatened status refer to...

```{r,echo=FALSE,message=FALSE,error=FALSE}
if(!connected){
  kable(data.frame(message="There is no database called sp_list: we cannot show the table"),caption="Table for threatened status not found",label="threatstatus")
}else{
  kable(dbReadTable(db,"threat_status"),caption="Table for threatened status description",label="threatstatus")
}
```

#### Adding a status to an existing species


Let's add an threatened status to the virtual species we invented ('Invented species')

```{python}
status1={'canonicalname':'Invented species',
  'threatstatus':'DD',
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A second reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'This is a first comment | Feeding habits: Does not eat at all!'}
res=requests.post(api_url+endpoint,json=status1,auth= authTokenEditUser)
pp(res.json())
```

Now, if we use the /testThreat endpoint for this species, we will obtain:

```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'})
pp(res.json())
```

#### Adding a status and a species in one command


Let's invent a new species again (it's been deleted before) : "Newspecies nonexistens", it will have a "NT" status:

```{python}
status2={'canonicalname':'Newspecies nonexistens',
  'scientificname':'Newspecies nonexistens (marius 2022)',
  'authorship':'(marius 2022)',
  'parentcanonicalname':'Invented',
  'threatstatus':'NT',
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A third reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'random comment | repartition: nula'}
res=requests.post(api_url+endpoint,json=status2,auth= authTokenEditUser)
pp(res.json())

```

#### Error: threatened status not recognised

The argument 'threatstatus' accepts any value shown in the previous table.
However, a simple orthographic results in an error.

For example:
Let's add the status 'E**M**' to *Juniperus communis*:

```{python}
requests.get(api_url+'/testThreat',json={'canonicalname':'Juniperus communis'}).json()
status3={'canonicalname':'Juniperus communis',
  'threatstatus':'EM',
  'ref_citation':['Bottin et al, 2022. False paper to show an example'],
  'link':['https://colsplist.herokuapp.com'],
  'comments':'random comment | repartition: nula'}
res=requests.post(api_url+endpoint,json=status3,auth= authTokenEditUser)
pp(res.json())
```

If the status provided is not recognized as one of the way to designate the status, the function send back this error.

#### What if the status already exists in the database

When the status already exists in the database, the behavior of the API depends on 2 parameters:

* priority: if 'high', the previous status is replaced, references are added (old references are kept anyway). I 'low' the previous status is kept, references are added.
* replace_comment: if True, the comments provided replace the old comments, otherwise comments are added to the existing ones (with a '|' separator)

Note that:

* the most logical cases are Priority:low + replace_comment:False or priority:high, replace_comment:True, but you might as well use priority and replace_comment independently to each other.
* There is no way to avoid that comments are either added or replacing old ones. So if you want to avoid comments to be inserted when the status already exists you will have to first test whether the statuses exist before sending data to the post method (with the '/testThreat(/list)' endpoint: see <https://github.com/marbotte/colSpList/blob/main/usage/testAndExamples/basic_getEndpoints_functionality.md#testthreat>).
* If priority is None (or is not provided by the user) and the status of the species is the same than in the database, the references and comment are added (with the method replace_comment or not) and no error is sent
* If priority is None (or is not provided by the user) and the status of the species different, an error is sent and no modification is made in the database.



##### example 1: priority:low, replace_comment:False

Let's say that we send again a status for the species *Newspecies nonexistens*, this time "EN", with the new reference: "Bottin, 2025. New fake reference with a weird date", and the comments. "threat evaluation methodology: None, this is only a fake species!"


As a reminder, here is the current status of the species:

```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

Now we modify it with:

```{python}
status4={'canonicalname':'Newspecies nonexistens',
  'threatstatus':'EN',
  'comments':'threat evaluation methodology: None, this is only a fake species!',
  'ref_citation':['Bottin, 2025. New fake reference with a weird date'],
  'priority':'low',
  'replace_comment':False
}
pp(requests.post(api_url+'/manageThreat',json=status4,auth=authTokenEditUser).json())
```


The new threat status is:

```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```
As you can see:

* new reference was added
* new comment was added
* threat stayed the same


##### example 2: priority: high, replace_comment:True

```{python}
status5={'canonicalname':'Newspecies nonexistens',
  'threatstatus':'EN',
  'comments':'threat evaluation methodology 2: None, this is still only a fake species!',
  'ref_citation':['Bottin, 2026. New fake reference with a weirder date'],
  'priority':'high',
  'replace_comment':True
}
pp(requests.post(api_url+'/manageThreat',json=status5,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

As you can see:

* new reference was added
* comments were replaced
* threat changed into 'EN'

### PUT: modify a status

The PUT method here is exactly the same than the POST method with 'priority':'high'. The only difference is that it will send an error if the status does not exist. The rationale is that they are used in different context.
The POST method is used when a new dataset is available, and people want to update the information on the API, while the PUT method is used when some errors or inconsistencies are found in the API data...

Imagine that we found new data for 'Invented species': it is now accepted in the literature as 'VU'



```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'})
pp(res.json())
cd_tax=res.json().get('cd_tax_acc')
```


```{python}
status6={'cd_tax':cd_tax,
  'threatstatus':'VU',
  'ref_citation':['Bottin, 2051. New fake reference with the weirdest date'],
}
pp(requests.put(api_url+'/manageThreat',json=status6,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'})
pp(res.json())
```

### DELETE: suppress a reference associated with a status, or the status itself

The DELETE method, by default, concerns the references associated to a status. If what you want to delete is the status, you have to use the 'delete_status' argument.

#### Deleting an association between a taxon status and a reference

The first thing to do is to search for the cd_ref and cd_tax corresponding respectively to the reference and the taxon.

In order to suppress the association between the reference 'Bottin et al, 2022. False paper to show an example' and the taxon 'Invented species', here is the way to search for the codes automatically:

```{python}
listRef=requests.get(api_url+'/listReferences').json()
cd_ref = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
pp(cd_ref)
cd_tax=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'}).json()['cd_tax']
pp(cd_tax)
```
Let's take a look at the threatened status of *Invented species*.

```{python}
pp(requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'}).json())
```


Here to suppress the association:

```{python}
res=requests.delete(api_url+'/manageThreat', json={'cd_tax':cd_tax,'cd_ref':cd_ref},auth=authTokenEditUser)
pp(res.json())
```


```{python}
pp(requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'}).json())
```

#### Deleting an association between a taxon status and a reference

If the delete method is called only with a cd_tax here is what happens:


```{python}
pp(requests.delete(api_url + '/manageThreat',json={'cd_tax':cd_tax},auth=authTokenEditUser).json())
```

As said, to delete the threatened status of 'Invented species', what should be done is:


```{python}
pp(requests.delete(api_url + '/manageThreat',json={'cd_tax':cd_tax,'delete_status':True},auth=authTokenEditUser).json())
```


```{python}
pp(requests.get(api_url+'/testThreat',json={'canonicalname':'Invented species'}).json())
```


### Cleaning

**Species to suppress**: 

'Newspecies nonexistens'

**References to suppress**:

'Bottin et al, 2022. False paper to show an example','A second reference just for fun!','A third reference just for fun!','Bottin, 2025. New fake reference with a weird date','Bottin, 2026. New fake reference with a weirder date','Bottin, 2051. New fake reference with the weirdest date'


```{python}
cd_tax_ToDel=requests.get(api_url + '/tax',json={'canonicalname':'Newspecies nonexistens'}).json().get('cd_tax')
requests.delete(api_url+'/manageTaxo',json={'cd_tax':cd_tax_ToDel},auth=authTokenEditUser)
cd_tax_StatusToDel=requests.get(api_url + '/testThreat',json={'canonicalname':'Invented species'}).json().get('cd_tax')
res=requests.delete(api_url+'/manageThreat',json={'cd_tax':cd_tax_StatusToDel, 'delete_status':True}, auth=authTokenEditUser)
res=requests.delete(api_url+'/cleanDb',json={'ref_no_status':True}, auth=authTokenEditUser)
```



## Endpoint /manageThreat/list

The endpoint /manageThreat/list works exactly like the endpoint /manageThreat, except that all the insertions, modifications or deletions may be done at once with a list.

### POST

See explanation in section POST of the /manageThreat endpoint.



We will show here how to post multiple statuses in a single call to the API.

Of course, many of these statuses concern the species "Newspecies nonexistens", which is not the intended objective of the multiple version in the endpoint /manageThreat/list, but the objective here is to show a proof of concept...

```{python}
statuses=[status1,status2,status3,status4,status5]
pp(statuses)
res=requests.post(api_url + '/manageThreat/list',json={'list':statuses},auth=authTokenEditUser)
pp(res.json())
```




### PUT

We will show here how to modify multiple statuses in a single call to the API.

```{python}
newSpecies=requests.post(api_url+'/testThreat/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json()
pp(newSpecies)
newSpecies_cd_tax=[n['cd_tax_acc'] for n in newSpecies]
modifications={'list':
  [
    {
      'cd_tax': newSpecies_cd_tax[0],
      'threatstatus':'LC',
      'ref_citation':['Fake report to put Invented species as LC'],
      'link':['https://www.afalsesiteasanexample.com'],
      'comments': 'a comment as replacement',
      'replace_comment':True
    },
    {
      'cd_tax': newSpecies_cd_tax[1],
      'threatstatus':'CR',
      'ref_citation':['Another fake report'],
      'comments': 'a comment to add',
    }
  ]
}
pp(modifications)
modifs=requests.put(api_url + '/manageThreat/list',json=modifications,auth=authTokenEditUser).json()
pp(modifs)
pp(requests.post(api_url+'/testThreat/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```




### DELETE

We will show here how to delete multiple references/statuses in a single call to the API.

We will suppress the references 'Bottin et al, 2022. False paper to show an example' and 'Fake report to put Invented species as LC' as justifications for *Invented species*, and delete the threatened status for *Newspecies nonExistens*

```{python}
pp(requests.post(api_url+'/testThreat/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
listRef=requests.get(api_url+'/listReferences').json()
cd_ref1 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
cd_ref2 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Fake report to put Invented species as LC'][0]
deletions=[
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref1},
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref2},
  {'cd_tax':newSpecies_cd_tax[1],
  'delete_status':True}
]
pp(deletions)
pp(requests.delete(api_url + '/manageThreat/list',json={'list':deletions},auth=authTokenEditUser).json())
pp(requests.post(api_url+'/testThreat/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```

### Cleaning

```{python}
pp(requests.delete(api_url + '/cleanDb',json={'status_no_ref':True,'ref_no_status':True},auth=authTokenEditUser).json())
pp(requests.delete(api_url + '/manageTaxo', json={'cd_tax':newSpecies_cd_tax[1]}, auth=authTokenEditUser).json())
```


## Endpoint /ManageExot

```{python}
endpoint='/manageExot'
```


### POST: adding alien-invasive species and/or the associated bibliographic references

The formally required arguments to post an alien-invasive status are:

* **is_alien**: a boolean(verdadero/falso) decribing the alien character of the species for Colombia
* **is_invasive**: a boolean(verdadero/falso) decribing the invasive character of the species for Colombia
* **ref_citation**: A list of bibliographic references associated with the alien-invasive status.

However, of course you will need at least one of 'canonicalname', 'scientificname' or 'gbifkey', for the API to know which taxon the alien-invasive status refer to...

#### Adding a status to an existing species


Let's add an alien-invasive status to the virtual species we invented ('Invented species')

```{python}
status1={'canonicalname':'Invented species',
  'is_alien': True,
  'is_invasive': False,
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A second reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'This is a first comment | Feeding habits: Does not eat at all!'}
res=requests.post(api_url+endpoint,json=status1,auth= authTokenEditUser)
pp(res.json())
```

Now, if we use the /testExot endpoint for this species, we will obtain:

```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'})
pp(res.json())
```

#### Adding a status and a species in one command


Let's invent a new species again : "Newspecies nonexistens", it will have an "Exotic":

```{python}
status2={'canonicalname':'Newspecies nonexistens',
  'scientificname':'Newspecies nonexistens (marius 2022)',
  'authorship':'(marius 2022)',
  'parentcanonicalname':'Invented',
  'is_alien':False,
  'is_invasive':True,
  'ref_citation':['Bottin et al, 2022. False paper to show an example','A third reference just for fun!'],
  'link':['https://colsplist.herokuapp.com',' '],
  'comments':'random comment | repartition: nula'}
res=requests.post(api_url+endpoint,json=status2,auth= authTokenEditUser)
pp(res.json())

```

#### What if the status already exists in the database

When the status already exists in the database, the behavior of the API depends on 2 parameters:

* priority: if 'high', the previous status is replaced, references are added (old references are kept anyway). I 'low' the previous status is kept, references are added.
* replace_comment: if True, the comments provided replace the old comments, otherwise comments are added to the existing ones (with a '|' separator)

Note that:

* the most logical cases are Priority:low + replace_comment:False or priority:high, replace_comment:True, but you might as well use priority and replace_comment independently to each other.
* There is no way to avoid that comments are either added or replacing old ones. So if you want to avoid comments to be inserted when the status already exists you will have to first test whether the statuses exist before sending data to the post method (with the '/testExot(/list)' endpoint: see <https://github.com/marbotte/colSpList/blob/main/usage/testAndExamples/basic_getEndpoints_functionality.md#testthreat>).
* If priority is None (or is not provided by the user) and the status of the species is the same than in the database, the references and comment are added (with the method replace_comment or not) and no error is sent
* If priority is None (or is not provided by the user) and the status of the species different, an error is sent and no modification is made in the database.



##### example 1: priority:low, replace_comment:False

Let's say that we send again a status for the species *Newspecies nonexistens*, this time "Almost endemic", with the new reference: "Bottin, 2025. New fake reference with a weird date", and the comments. "endemism evaluation methodology: None, this is only a fake species!"


As a reminder, here is the current status of the species:

```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

Now we modify it with:

```{python}
status4={'canonicalname':'Newspecies nonexistens',
  'is_alien':False,
  'is_invasive':False,
  'comments':'invasive evaluation methodology: None, this is only a fake species!',
  'ref_citation':['Bottin, 2025. New fake reference with a weird date'],
  'priority':'low',
  'replace_comment':False
}
pp(requests.post(api_url+'/manageExot',json=status4,auth=authTokenEditUser).json())
```


The new endemism status is:

```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```
As you can see:

* new reference was added
* new comment was added
* invasive status stayed the same


##### example 2: priority: high, replace_comment:True

```{python}
status5={'canonicalname':'Newspecies nonexistens',
  'is_alien':False,
  'is_invasive':False,
  'comments':'invasive evaluation methodology 2: None, this is still only a fake species!',
  'ref_citation':['Bottin, 2026. New fake reference with a weirder date'],
  'priority':'high',
  'replace_comment':True
}
pp(requests.post(api_url+'/manageExot',json=status5,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Newspecies nonexistens'})
pp(res.json())
```

As you can see:

* new reference was added
* comments were replaced
* invasive status changed into False

### PUT: modify a status

The PUT method here is exactly the same than the POST method with 'priority':'high'. The only difference is that it will send an error if the status does not exist. The rationale is that they are used in different context.
The POST method is used when a new dataset is available, and people want to update the information on the API, while the PUT method is used when some errors or inconsistencies are found in the API data...

Imagine that we found new data for 'Invented species': it is now accepted in the literature as invasive



```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'})
pp(res.json())
cd_tax=res.json().get('cd_tax_acc')
```


```{python}
status6={'cd_tax':cd_tax,
  'is_alien':True,
  'is_invasive':True,
  'ref_citation':['Bottin, 2051. New fake reference with the weirdest date'],
}
pp(requests.put(api_url+'/manageExot',json=status6,auth=authTokenEditUser).json())
```

```{python}
res=requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'})
pp(res.json())
```

### DELETE: suppress a reference associated with a status, or the status itself

The DELETE method, by default, concerns the references associated to a status. If what you want to delete is the status, you have to use the 'delete_status' argument.

#### Deleting an association between a taxon status and a reference

The first thing to do is to search for the cd_ref and cd_tax corresponding respectively to the reference and the taxon.

In order to suppress the association between the reference 'Bottin et al, 2022. False paper to show an example' and the taxon 'Invented species', here is the way to search for the codes automatically:

```{python}
listRef=requests.get(api_url+'/listReferences').json()
cd_ref = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
pp(cd_ref)
cd_tax=requests.get(api_url+'/tax',json={'canonicalname':'Invented species'}).json()['cd_tax']
pp(cd_tax)
```
Let's take a look at the alien-invasive status of *Invented species*.

```{python}
pp(requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'}).json())
```


Here to suppress the association:

```{python}
res=requests.delete(api_url+'/manageExot', json={'cd_tax':cd_tax,'cd_ref':cd_ref},auth=authTokenEditUser)
pp(res.json())
```


```{python}
pp(requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'}).json())
```

#### Deleting an association between a taxon status and a reference

If the delete method is called only with a cd_tax here is what happens:


```{python}
pp(requests.delete(api_url + '/manageExot',json={'cd_tax':cd_tax},auth=authTokenEditUser).json())
```

As said, to delete the endemic status of 'Invented species', what should be done is:


```{python}
pp(requests.delete(api_url + '/manageExot',json={'cd_tax':cd_tax,'delete_status':True},auth=authTokenEditUser).json())
```


```{python}
pp(requests.get(api_url+'/testExot',json={'canonicalname':'Invented species'}).json())
```


### Cleaning

**Species to suppress**: 

'Newspecies nonexistens'

**References to suppress**:

'Bottin et al, 2022. False paper to show an example','A second reference just for fun!','A third reference just for fun!','Bottin, 2025. New fake reference with a weird date','Bottin, 2026. New fake reference with a weirder date','Bottin, 2051. New fake reference with the weirdest date'


```{python}
cd_tax_ToDel=requests.get(api_url + '/tax',json={'canonicalname':'Newspecies nonexistens'}).json().get('cd_tax')
requests.delete(api_url+'/manageTaxo',json={'cd_tax':cd_tax_ToDel},auth=authTokenEditUser)
cd_tax_StatusToDel=requests.get(api_url + '/testExot',json={'canonicalname':'Invented species'}).json().get('cd_tax')
res=requests.delete(api_url+'/manageExot',json={'cd_tax':cd_tax_StatusToDel, 'delete_status':True}, auth=authTokenEditUser)
res=requests.delete(api_url+'/cleanDb',json={'ref_no_status':True}, auth=authTokenEditUser)
```



## Endpoint /manageExot/list

The endpoint /manageExot/list works exactly like the endpoint /manageExot, except that all the insertions, modifications or deletions may be done at once with a list.

### POST

See explanation in section POST of the /manageExot endpoint.



We will show here how to post multiple statuses in a single call to the API.

Of course, many of these statuses concern the species "Newspecies nonexistens", which is not the intended objective of the multiple version in the endpoint /manageExot/list, but the objective here is to show a proof of concept...

```{python}
statuses=[status1,status2,status4,status5]
pp(statuses)
res=requests.post(api_url + '/manageExot/list',json={'list':statuses},auth=authTokenEditUser)
pp(res.json())
```




### PUT

We will show here how to modify multiple statuses in a single call to the API.

```{python}
newSpecies=requests.post(api_url+'/testExot/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json()
pp(newSpecies)
newSpecies_cd_tax=[n['cd_tax_acc'] for n in newSpecies]
modifications={'list':
  [
    {
      'cd_tax': newSpecies_cd_tax[0],
      'is_invasive':True,
      'is_alien':True,
      'ref_citation':['Fake report to put Invented species as invasive'],
      'link':['https://www.afalsesiteasanexample.com'],
      'comments': 'a comment as replacement',
      'replace_comment':True
    },
    {
      'cd_tax': newSpecies_cd_tax[1],
      'is_alien':True,
      'is_invasive': False,
      'ref_citation':['Another fake report'],
      'comments': 'a comment to add'
    }
  ]
}
pp(modifications)
modifs=requests.put(api_url + '/manageExot/list',json=modifications,auth=authTokenEditUser).json()
pp(modifs)
pp(requests.post(api_url+'/testExot/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```




### DELETE

We will show here how to delete multiple references/statuses in a single call to the API.

We will suppress the references 'Bottin et al, 2022. False paper to show an example' and 'Fake report to put Invented species as invasive' as justifications for *Invented species*, and delete the endemic status for *Newspecies nonexistens*

```{python}
pp(requests.post(api_url+'/testExot/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
listRef=requests.get(api_url+'/listReferences').json()
cd_ref1 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
cd_ref2 = [r['cd_ref'] for r in listRef if r['ref_citation']=='Fake report to put Invented species as invasive'][0]
deletions=[
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref1},
  {'cd_tax':newSpecies_cd_tax[0],
  'cd_ref':cd_ref2},
  {'cd_tax':newSpecies_cd_tax[1],
  'delete_status':True}
]
pp(deletions)
pp(requests.delete(api_url + '/manageExot/list',json={'list':deletions},auth=authTokenEditUser).json())
pp(requests.post(api_url+'/testExot/list',json={'list':[{'canonicalname':'Invented species'},{'canonicalname':'Newspecies nonexistens'}]}).json())
```

### Cleaning

```{python}
pp(requests.delete(api_url + '/cleanDb',json={'status_no_ref':True},auth=authTokenEditUser).json())
pp(requests.delete(api_url + '/manageTaxo', json={'cd_tax':newSpecies_cd_tax[1]}, auth=authTokenEditUser).json())
```
# Endpoint /manageRef : modifying and supressing references

## PUT:modifying the references

Here are the references 'A second reference just for fun!', 'A third reference just for fun!' and 'Bottin et al, 2022. False paper to show an example':


```{python}
listRef=requests.get(api_url+'/listReferences').json()
refToModify=[r for r in listRef if r['ref_citation'] in ['A second reference just for fun!', 'A third reference just for fun!', 'Bottin et al, 2022. False paper to show an example']]
pp(refToModify)
```

We can modify by changing the description:

```{python}
pp(requests.put(api_url + '/manageRef', json={'cd_ref':refToModify[0]['cd_ref'],'reference':'New text for the ref'}, auth=authTokenEditUser).json())
```


We can modify by changing the link:

```{python}
pp(requests.put(api_url + '/manageRef', json={'cd_ref':refToModify[1]['cd_ref'],'link':'http://justanotherwebsite.com'}, auth=authTokenEditUser).json())
```

```{python}
listRef=requests.get(api_url+'/listReferences').json()
cds_ref=[r['cd_ref'] for r in refToModify]
refModified=[r for r in listRef if r['cd_ref'] in cds_ref]
pp(refModified)
```
## DELETE: merging and/or deleting the references

Let's imagine that we inserted the references 'New text for the ref' and 'A third reference just for fun!', but they are indeed the same references. Then we need to delete 'New text for the ref', but we want first to transfer all the status into 'A third reference just for fun!'. This can be done by using the following code:

```{python}
cd_ref=[r['cd_ref'] for r in refModified if r['ref_citation']=='New text for the ref'][0]
mergeInto=[r['cd_ref'] for r in refModified if r['ref_citation']=='A third reference just for fun!'][0]
pp(requests.delete(api_url + '/manageRef', json={'cd_ref':cd_ref,'mergeInto':mergeInto}, auth=authTokenEditUser).json())
listRef=requests.get(api_url+'/listReferences').json()
refModified=[r for r in listRef if r['cd_ref'] in cds_ref]
pp(refModified)
```

You may see that all the statuses have been transfered from 'New text for the ref' to 'A third reference just for fun!' before deleting 'New text for the ref'!

Now, a simple deletion without transfer may be done by:

```{python}
cd_ref=[r['cd_ref'] for r in refModified if r['ref_citation']=='Bottin et al, 2022. False paper to show an example'][0]
pp(requests.delete(api_url + '/manageRef', json={'cd_ref':cd_ref}, auth=authTokenEditUser).json())
listRef=requests.get(api_url+'/listReferences').json()
refModified=[r for r in listRef if r['cd_ref'] in cds_ref]
pp(refModified)
```



# Finally : getting back to the previous state

Let's clean the database from all the modifications:

```{python}
taxToSuppList=['Invented species','Juniperus communis','Vultur fossilis','Juniperus sabina']
taxToSupp=[{'canonicalname':r} for r in taxToSuppList]
res=requests.post(api_url+'/tax/list',json={'list':taxToSupp}).json()
cd_tax_supp=[{k:v for (k,v) in r.items() if k=='cd_tax'} for r in res]
pp(requests.delete(api_url+'/manageTaxo/list',json={'list':cd_tax_supp},auth=authTokenEditUser).json())
pp(requests.delete(api_url+'/cleanDb',json={'status_no_ref':True,'ref_no_status':True,
'syno_no_tax':True,'tax_no_status':True},auth=authTokenEditUser).json())
```




Here, I will delete the users that were created for this document and give back the previous password to the 'admin' user:


```{python}
endpoint="/admin/users"
# Deleting the users created for this document
userToDel={'username':'editUser'}
res=requests.delete(api_url+endpoint,json=userToDel,auth=authAdmin)
pp(res.json())
endpoint="/user"
res=requests.put(api_url+endpoint,json={'newPassword':codeAdmin},auth=authTokenAdmin)
pp(res.json())

```
